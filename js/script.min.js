if (!String.prototype.trim) {
    String.prototype.trim = function() {
        return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
    }
}

class StringUtil {
    static removeAccents(str) {
        return str.normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .replace(/đ/g, 'd').replace(/Đ/g, 'D')
    }
}

class ArrayUtil {
    static intersectionBetween(arr1, arr2) {
        const setA = new Set(arr1)
        const setB = new Set(arr2)

        let intersectionResult = []

        for (let i of setB) {

            if (setA.has(i)) {
                intersectionResult.push(i)
            }

        }

        return intersectionResult
    }

    static intersection(arr) {
        if (!arr.length) return []
        if (!arr.length == 1) return arr[0]

        let result = arr[0]
        for (let item of arr) {
            result = ArrayUtil.intersectionBetween(result, item)
        }
        return result
    }
}


class Dictionary {
    constructor(words, definitions, relations) {
        this.buildWordToId(words)
        this.buildIdToWord(words)
        this.buildIdToDefinition(definitions)
        this.buildRelation(relations)
    }

    buildIdToWord(words) {
        this._words = this.buildModel(words)
    }

    buildIdToDefinition(definitions) {
        this._definitions = this.buildModel(definitions)
    }

    buildRelation(relations) {
        this._wordToDefinition = {}
        this._synonyms = {}
        for (let item of relations) {
            if (!(item.wordId in this._wordToDefinition))
                this._wordToDefinition[item.wordId] = new Set()
            this._wordToDefinition[item.wordId].add(item.definitionId)


            if (!(item.definitionId in this._synonyms))
                this._synonyms[item.definitionId] = new Set()
            this._synonyms[item.definitionId].add(item.wordId)
        }

        // Convert Set to Array
        for (const wordId in this._wordToDefinition)
            this._wordToDefinition[wordId] = Array.from(this._wordToDefinition[wordId])

        for (const definitionId in this._synonyms)
            this._synonyms[definitionId] = Array.from(this._synonyms[definitionId])
    }

    buildModel(data) {
        let result = {}
        for (let item of data) {
            if (!('id' in item) || !('name' in item)) continue

            result[item.id] = item.name
        }
        return result
    }

    buildWordToId(words) {
        if (!(words instanceof Array)) {
            throw 'The words data is not valid.'
        }

        this._invertedIndex = {}
        for (let word of words) {
            let wordArr = StringUtil.removeAccents(word.name).split(" ")

            if (!wordArr.length) continue

            for (let w of wordArr) {
                let trimmedWord = w.trim()

                if (!trimmedWord.length) continue

                if (!(trimmedWord in this._invertedIndex)) {
                    this._invertedIndex[trimmedWord] = new Set()
                }

                this._invertedIndex[trimmedWord].add(word.id)
            }
        }

        // Convert Set to Array
        for (const word in this._invertedIndex)
            this._invertedIndex[word] = Array.from(this._invertedIndex[word])
    }

    getWordsByIds(ids) {
        let result = []
        for (let id of ids) {
            if (!(id in this._words)) continue
            result.push(this._words[id])
        }
        return result
    }

    getDefinitionById(id) {
        if (id in this._definitions)
            return this._definitions[id]

        return null
    }

    getIdsByKeyWord(keyword) {
        if (keyword in this._invertedIndex) {
            return this._invertedIndex[keyword]
        }
        return []
    }

    getDefitionIdsByWordIds(wordIds) {
        let result = new Set()
        if (wordIds.length) {
            for (let wordId of wordIds) {
                if (!(wordId in this._wordToDefinition)) continue
                this._wordToDefinition[wordId].forEach(definitionId => {
                    result.add(definitionId)
                })
            }
        }

        return Array.from(result)
    }

    getSynonymsByDefinitionId(definitionId) {
        let result = []
        if (definitionId in this._synonyms)
            result = this.getWordsByIds(this._synonyms[definitionId])

        return result
    }

    search(keywords) {
        let keywordArr = StringUtil.removeAccents(keywords).trim().split(" "),
            result = []

        if (keywordArr.length) {
            let byWordResultId = []
            for (let keyword of keywordArr) {
                let wordIds = this.getIdsByKeyWord(keyword)
                if (wordIds.length)
                    byWordResultId.push(wordIds)
            }

            let resultWordIds = ArrayUtil.intersection(byWordResultId)
            if (resultWordIds.length) {
                let resultDefinitionIds = this.getDefitionIdsByWordIds(resultWordIds)
                for (let definitionId of resultDefinitionIds) {
                    let synonyms = this.getSynonymsByDefinitionId(definitionId),
                        definition = this.getDefinitionById(definitionId)
                    if (!synonyms.length || !definition) continue
                    result.push({
                        synonyms: synonyms,
                        definition: definition,
                    })
                }

            }
        }

        return result
    }
}

const wrapper = document.querySelector(".wrapper"),
    searchInput = wrapper.querySelector("input"),
    searchResult = wrapper.querySelector(".search-result"),
    infoText = wrapper.querySelector(".info-text"),
    removeIcon = wrapper.querySelector(".search i.close-icon"),
    dictionary = new Dictionary(words, definitions, relations),
    resultTemplate = wrapper.querySelector("#result-template")

function clearSearchResult() {
    searchResult.content = ''
    searchResult.innerHTML = ''
}

function updateData(word, results) {
    clearSearchResult()
    wrapper.classList.add("active")
    if (!results.length)
        infoText.innerHTML = `không tìm thấy kết quả cho <b>${word}</b>`
    else {
        infoText.innerHTML = `tìm thấy ${results.length} kết quả`
        for (let res of results) {
            let item = resultTemplate.content.cloneNode(true)
            item.querySelector(".synonyms p").innerHTML = res.synonyms.join(", ")
            item.querySelector(".definition span").innerHTML = res.definition
            searchResult.appendChild(item)
        }
    }
}

function search(word) {
    wrapper.classList.remove("active")
    infoText.style.color = "#000"
    infoText.innerHTML = `đang tìm kiếm...`

    let results = dictionary.search(word.toLowerCase())
    updateData(word, results)

    searchInput.value = word
}

searchInput.addEventListener("keyup", e => {
    let word = e.target.value.replace(/\s+/g, ' ')
    if (e.key == "Enter" && word) {
        search(word)
    }
})

removeIcon.addEventListener("click", () => {
    searchInput.value = ""
    searchInput.focus()
    wrapper.classList.remove("active")
    clearSearchResult()
    infoText.style.color = "#9A9A9A"
    infoText.innerHTML = "gõ từ gì đó vô đây để tìm kiếm"
})